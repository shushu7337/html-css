<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
    <title>Game</title>
</head>
<body>
    <div class="content">
        <div class="row">
            <img src="normal.png" class="cell" title="normal">
            <img src="normal.png" class="cell" title="normal">
            <img src="normal.png" class="cell" title="normal">
        </div>
        <div class="row">
            <img src="normal.png" class="cell" title="normal">
            <img src="normal.png" class="cell" title="normal">
            <img src="normal.png" class="cell" title="normal">
        </div>
        <div class="row">
            <img src="normal.png" class="cell" title="normal">
            <img src="normal.png" class="cell" title="normal">
            <img src="normal.png" class="cell" title="normal">
        </div>
   
        <div class="control">
            <div class="msg">
                <span id="time">TIME:0s</span>
                <button>START</button>
                <span id="combo">SCORE:0</span>
            </div>
            <hr>
            <strong>遊戲說明</strong>
            <p>按下START後，請使數字鍵盤做打擊</p>
            <hr>
        </div>
    </div>
    <script>

        //Start 初始化 作為全域變數
        let btn=document.getElementsByTagName("button")[0];
        btn.addEventListener("click",gamestart);    //監聽點擊click,及觸發gamestart函式

        let time=document.getElementById("time");   //顯示時間的文字標籤
        let combo=document.getElementById("combo");     //顯示分數的文字標籤
        let sec=0,count=0;   //紀錄數據的變數

        let space=document.getElementsByClassName("cell");
        let beAngry=new Array();

        // gamestart 遊戲開始
        function gamestart(){
            btn.removeEventListener("click",gamestart);     //暫時取消監聽click觸發函式，一樣要寫(行為,函式)是因為如果有多個監聽行為的話要指定是哪一個行為與函式

            sec=60, count=0;
            time.textContent=`剩餘時間:${sec}s`;    //先載入一開始時間
            combo.textContent=`成績分數:${count}`;

            // 每秒畫面上的固定面話語遊戲按鈕操作限制
            let timeRun = setInterval(() => {
                if(sec==0){
                    clearInterval(timeRun);      //停止timeRun
                    btn.addEventListener("click",gamestart);  //秒數歸零後，再將監聽行為賦予回來
                }
                else{
                    sec--;
                    time.textContent=`剩餘時間:${sec}s`;
                }
                },1000)


            for ( let i=0; i<100; i++){     //在for迴圈的100次中，每一次都是獨立的出場設定
                let which=Math.floor(Math.random()*9);    //隨機0~8格位置
                let onTime=Math.floor(Math.random()*58000);   //隨機時間點 0~55000ms  (如果以秒來計算的話，100之裡面放再55秒會有重複，所以放大到毫秒)
                let delay=Math.floor(Math.random()*2+2);    //出場停留時間 2~4秒
            
                setTimeout(()=>{//在setTimeout(啟動showIt(哪個位置,延遲幾秒,第幾//時間太快，滿格時會死掉
                    showIt(which,delay,i);
                },onTime)
            }
        }
        
        // 轉換圖片
        function showIt(siWhich,siDelay,siId){

            if(space[siWhich.title!="yellow"]){   //當該位置不是正常圖的時候
                //要改位置或改時間
                // let newWhich=(siWhich==8)?0:siWhich+1;     //如果siWhich為8的時候為0，不是的話就+1(三元運算)--type 1 
                // let newWhich=(siwhich+1)%9;                   //type 2 取餘數
                let newWhich = Math.floor(Math.random()*9)    //tyep 3 隨機算位置
               
                setTimeout(()=>{    //時間太快，滿格會死掉
                    showIt(NewWhich,siDelay,siId);
                },1000)
                
            }
            else{
                // 轉換生氣圖
                space[siWhich].src="angry.png"
                space[siWhich].style.background="lightsalmon";
                space[siWhich].title="red";
                // 插入html - alt屬性 賦予siID值
                space[siWhich].alt = siId;

                // 生氣轉回正常(當為敲擊的時候，自己轉回正常版)
                beAngry[siId]=setTimeout(()=>{  //用beAngry陣列存入[siId]
                    space[siWhich].src="normal.png"
                    space[siWhich].removeAttribute("style");
                    space[siWhich].title="yellow";
                },siDelay*1000)
            }
         }



        //  鍵盤事件，去(觸發)計算該(轉換代號之)位置是否得分
         document.onkeydown=kbCode;     //每次按下鍵盤會執行的函式(kbCode)
         function kbCode(){
            //  console.log(event.keyCode);
             switch (event.keyCode){
                 case 103:  getCount(0);  break;
                 case 104:  getCount(1);   break;
                 case 105:  getCount(2);   break;
                 case 100:  getCount(3);   break;
                 case 101:  getCount(4);   break;
                 case 102:  getCount(5);   break;
                 case 97:   getCount(6);   break;
                 case 98:   getCount(7);   break;
                 case 99:   getCount(8);   break;
             }
         }

         //滑鼠事件
         for(let i=0; i<space.length;i++){
            //  console.log(key,space[key]);
                     space[i].addEventListener("click",()=>{
                         getCount(i);
                     });
        }


        //  生氣圖轉平和圖
         function getCount(item) {

            if(space[item].title == "red"){
                //  當下的位置space[item]變為平和的圖片
                space[item].src="eat.png"
                space[item].style.background="lightgreen";
                space[item].title="green";

                // 得分
                count++;
                combo.textContent = `成績分數:${count}`;

                // 生氣轉回正常(當為敲擊的時候，自己轉回正常版)
                setTimeout(()=>{
                    space[item].src="normal.png"
                    space[item].removeAttribute("style");
                    space[item].title="yellow";
                },1000);
                
                // 清除原先的未敲擊之恢復事件
                id=space[item].alt;
                clearTimeout(beAngry[id]);
                space[item].alt=null;
            }
         }
    </script>
</body>
</html>