<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <h1>Hello world!!</h1>

    <script>
        // Jsの初體驗
        /* Jsの初體驗*/
        
        //aa=100; /*aa是一個變數 我們指定數字100給100進行暫存*/
        // 可以在網頁F12內的 Console內看到Js的模樣
        
        //alert(aa); /*呼叫提示視窗的函式 (old) */
        // alert會卡住，而且會被client端看到，可以的話盡可能的使用console.log會比較OK(也請視情況而定)
        
        //console.log(aa); //要求寫到console的函式 (new)

        // Javascript不用;作為斷行符號也可以 但可以的話掀出來

        // aa=hello;
        // bb=world;
        // console.log(aa+bb);
        // console.log(`hello world my friend`);
        // 也等於
        // console.log(`${aa} ${bb} my friend);
        // title="冷笑話"
        // title=title+":"
        // 也等於
        // title+=":"
        // who = "小明"
        // where="超商",why="為什麼",when="繳費",how="坐者輪椅"
        
        // new
        // console.log(`${title}${why}${who}去${where}${when}後，${who}出來卻要${how}`);

        // old版 字串前後都要+ +
        // console.log(title+why+who+"去"+where+when+"後,"+who+"出來卻要"+how+"?");
        // VM4685:1 冷笑話:為什麼小明去超商繳費後，小明出來卻要坐者輪椅

        // a=40
        // 40
        // b=200
        // 200
        // a==b
        // false
        // AA=a==b
        // false
        // AA
        // false
        // typeof(AA)
        // "boolean"
        // a!=b
        // true
        // a===b
        // false
        // a=40
        // 40
        // b="40"(字串)
        // "40"
        // a==b(廣義的等於)
        // true
        // 絕對等於(狹義的等於*會判斷他的形式)
        // a===b
        // false
        // sayhi("shu");
        // aaa();
        // aaa;
        // aaa
        // ƒ aaa(){
        //             alert("hello,mother fucker!!");
        //         }


        typeof(aaa);
        function aaa(){
            alert("hello,mother fucker!!");
        }
        function sayhi(name){
            alert("hello!!"+name+"!!,mother fucker");
            // alert(`hello!!${name}!!,mother fucker`);
        }

        // 使用變數的function會比較有變化，且此為沒有名字的函式
        word1=function(){   //結構為函式的變數1
            console.log("hello!!");
        }
        word2=function(){   //結構為函式的變數2
            console.log("mother,fucker!!");
        }

        function say(who){  //負責將接收到的變數做()執行
            who();
        }
        // say 是函式,word1跟word2是變數，who 是函式say內的變數

        function show(name){
            return "hi," +name+" slut";
        }

        say1=function show(name){ //函式型變數內的fuction有沒有名字沒差，沒名字的function我們稱呼為匿名函式
            return "hi," +name;
        }


        // who("shu");
        // 是看不到東西的
        // 請服用console.log
        console.log(show("shu"));
        console.log("hi,shu slut");

        say2=function(){
            console.log("this is say2")
        }();
        // 上方變數say2的最後加上()會直接執行function指令，而變數say2沒有暫存任何東西即無法定義

        say2=function(){
            console.log("this is say2")
            return "Done";
        }();
        // 在say2變數中的function 內加上return "Done":會是一個匿名函式執行後的回傳(文字)，此時say2是一個文字變數(typeof會顯示string)
        /*→ 
            say2;
            "Done"
        */


        // (函式)(執行)
        // 匿名函式 & 直接執行，注意若要這麼做那麼匿名函式需要先包起來做優先處理(表示為函式內容物)
        (function(){
            console.log("this is no name fn")
        })();

        (function ccc(){
            console.log("this is ccc fn")
        })();

        a="shu";

        (function ccc(name){
            console.log("this is abc fn "+ name);
        })(a); //直接執行的地方嘗試丟一個變數

        (function ccc(){
            console.log("this is unname fn "+ a);
        })(); //直接執行的地方嘗試丟一個變數

        // 如果要活用函式的話建議是使用變數來做


        function MyMod(){ //函式 Moudle 結構
            function dogsay(){
                console.log("汪!");
            }
            function catsay(){
                console.log("喵!");
            }

            // 回傳一個物件
            return{

        // (key):(value)

            dog: dogsay,
            cat: catsay,
            god: "Ya!!"
            };
        };

        /* 範例一
        ->MyMod().dog()
        
        <-汪!
        */
        /*範例二
        ->MyMod().god
        
        <-"Ya!!"
        */


        // 物件型變數的宣告
        yee={
            a:1,
            b:2
        }
        /*
        在yee後面直接.(key)會直接顯示他的(value值)
        ->　　yee.b
        <　　　-2
    ---------------------
        ->　　yee.a
        <　　　-1
        */
        // ->typeof(MyMod())
        // 這裡表示(MyMod為一個物件)
        // <-"object"


        // this 是指目前的位置(物件)
        function showThis(){
            // this指的是此瀏覽器的物件(window)目前的對象
            // 每個函式內的變數都是獨立且與其他非同物件的同名變數不受影響

            // 重點是this在的位置在哪裡才會影響那個位置的函式物件
            console.log(this.MyCard);
        }
        MyCard="紅心A";

        Myobj={
            // 記得物件要用 : 不是 = 
            MyCard: "黑桃A",
            first: showThis,
            // 巢狀是物件
            second:{
                MyCard:"方塊A",
                gold5:showThis
            }
        };
        /*
        --目前的yee--
        -> this.yee
        
        <- {a: 1, b: 2}
        --宇宙的yee--
        -> window.yee
        
        <- {a: 1, b: 2}
        --現在的yee--
        -> yee
        
        <- {a: 1, b: 2}

        */

        // ES6 多了可指定變數之預設內容
        function num(a=100) {
            console.log(a);
        };



        /**************變數***************/

        // var | let (ES6) ,const (ES6)

        
        myVar="臨時變數";       //這樣很危險因為使用者可以自行更改
        var myVar2="全域變數";  //同上
        let myVar3="區域{}內的獨立變數";
        const myVar4="常態變數";    //一旦宣告後即不能更改


        var a=100;  //全域變數
        const b=300;
        // b=400;  因b已經使用const去做設定，故另外設立b=400會顯示錯誤
        let c=999;


        function test(){
            // var b 無法被讀取，在function 內的變數是無法被讀取的  //區域變數:只在此函式有用
            var b=200;
            console.log(a,b);
        }
        // 如果函式內的var b註解掉後，會找外面的var b
        test();

        if(true){   //let 只會獨立在{}世界內使用，且可不影響{}外的世界

            /* 
                使用不同套件的時候，常會有變數名稱被const咬住，而在不同套件同時使用時，
            相同的變數名稱會導致crash，故會使用let居多(保護自己亦保護別人)
             */
            let b=400;
            let c=9;  //在區域內重新定義c為9 
            // 注意同一範圍的 const 與 let 不能重複宣告 var可以
            console.log(b,c);
        }

        console.log(b,c);

        d=123;  //臨時性宣告變數d為123

        function testvar(){
            console.log(d);
        }
        
        delete a;
        console.log(a);
        delete b;
        console.log(b);
        // a,b皆不能被刪除
        
        // delete d;
        // console.log(d);

        /*
            let e=20;
            let f=30;
            let g=40;
        */
        let e=20,f=30,g=40; //很多場合都會出現 ， 代表多筆參數或指定
        
        //  初始條件;   布林值;   結束條件設定;
        for(let i=0,j=10;i<10;i++,j--){      //以防外部的相同變數名稱會影響迴圈，會在迴圈中使用let在宣告一次做保護
            console.log(`i=${i},j=${j}`);
        }

        var isA=3;         
        var isB=null;      
        var isC;           
        var isD="";      


        var isBBB=function(){
            alert(23);
        }

        isBBB=null;

        /*
        ->  isA
        <-  3
        ->  typeof(isA)
        <-  "number"
-------------------------
        ->  isB
        <-  null
        ->  typeof(isB)
        <-  "object"
-------------------------
        ->  isC
        <-  undefined
        ->  typeof(isC)
        <-  "undefined"
-------------------------
        ->  isD
        <-  ""
        ->  typeof(isD)
        <-  "string"
-------------------------
        ->  isBBB
        <-  null
        ->  typeof(isBBB)
        <-  "object"
        
        
        */















    </script>
</body>
</html>